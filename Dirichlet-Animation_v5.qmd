---
title: "Dirichlet"
format: html
---



```{r}
library(ggplot2)
library(gganimate)
library(dplyr)
library(magick)
library(MCMCpack)  # for rdirichlet
library(gtools)  # for ddirichlet
library(patchwork)  # for combining plots

```

You can add options to executable code like this 

```{r}
set.seed(42)

# Parameters
alpha1_values <- seq(1, 0.1, by = -0.1)  # starts high, ends low
alpha2_values <- seq(1, 0.1, by = -0.1)   # starts low, ends high
alpha3_values <- seq(1, 0.1, by = -0.1)   # starts low, ends high
# #

# Parameters
# alpha1_values <- seq(1, 5, by = 0.1)  # starts high, ends low
# alpha2_values <- seq(1, 5, by = 0.1)   # starts low, ends high
# alpha3_values <- seq(1, 5, by = 0.1)   # starts low, ends high
#



#alpha3 <- 1.0                            # fixed

n_samples <- 2000

# Triangle vertices
v1 <- c(1, 0)  # corresponds to (1,0,0)
v2 <- c(0, 1)  # corresponds to (0,1,0)
v3 <- c(0, 0)  # corresponds to (0,0,1)



label_df <- data.frame(
  x = c(v1[1], v2[1], v3[1]),
  y = c(v1[2], v2[2], v3[2]),
  label = c("(1,0,0)", "(0,1,0)", "(0,0,1)"),
  nudge_x = c(-0.08, 0.1, 0),   # left, right, no horizontal shift
  nudge_y = c(0, 0, 0.08)       # no vertical shift, no shift, upward
)

arrow_df <- data.frame(
  x = c(1, 0),
  y = c(0, 1)
)


# Function to project Dirichlet sample to triangle
project_to_triangle <- function(x1, x2, x3) {
  x <- x1 * v1[1] + x2 * v2[1] + x3 * v3[1]
  y <- x1 * v1[2] + x2 * v2[2] + x3 * v3[2]
  return(data.frame(x = x, y = y))
}

# Generate animation data
animation_data <- data.frame()

for (i in seq_along(alpha1_values)) {
  alpha1 <- alpha1_values[i]
  alpha2 <- alpha2_values[i]
  alpha3 <- alpha2_values[i]
  samples <- rdirichlet(n_samples, c(alpha1, alpha2, alpha3))
  projected <- project_to_triangle(samples[,1], samples[,2], samples[,3])
  
  projected$alpha1 <- alpha1
  projected$alpha2 <- alpha2
  projected$frame <- i
  
  animation_data <- rbind(animation_data, projected)
}


# Triangle outline in 2D projection
triangle_df <- data.frame(
  x = c(v1[1], v2[1], v3[1], v1[1]),
  y = c(v1[2], v2[2], v3[2], v1[2])
)

```

```{r}
ggplot(subset(animation_data, frame == 1), aes(x = x, y = y)) +
  geom_point(alpha = 0.3, color = "darkblue") +
  ggtitle("Initial Frame: Uniform Prior: alpha = (1,1,1)")


ggplot(subset(animation_data, frame == max(animation_data$frame)), aes(x = x, y = y)) +
  geom_point(alpha = 0.3, color = "darkgreen") +
  ggtitle("Final Frame: Concetrated Prior: alpha = (.1,.1,.1)")

```



```{r}
p <- ggplot(animation_data, aes(x = x, y = y)) +
  geom_point(alpha = 0.3, size = 0.8, color = "steelblue") +
  geom_density_2d(color = "red", alpha = 0.7) +
  geom_path(data = triangle_df, aes(x = x, y = y), color = "black", size = 1) +
  annotate("segment", x = 1, y = 0, xend = 0, yend = 1,
         arrow = arrow(length = unit(0.2, "cm")),
         color = "darkgreen", size = 1.2) +
  xlim(0, 1) + ylim(0, 1) +
  geom_text(data = label_df,
          aes(x = x, y = y, label = label),
          nudge_x = label_df$nudge_x,
          nudge_y = label_df$nudge_y,
          size = 4, fontface = "bold", color = "black") +
  labs(
  title = "Dirichlet Prior Evolution in Markov Chain",
  subtitle = "Dirichlet Prior: (α₁ → α₂): shifting belief from state 1 to state 2",
  x = "Projected X",
  y = "Projected Y",
  caption = "Transitioning belief from state 1 → state 2"
) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.title = element_text(size = 12),
    plot.caption = element_text(size = 10, hjust = 0.5)
  ) +
  transition_states(frame,
                    transition_length = 1,
                    state_length = 2) +
  ease_aes('sine-in-out')

p
```

The animation begins with $\alpha = (1,1,1)$, representing a uniform prior over the three states and maximum entropy. As the frames progress, the parameters $\alpha$ moves towards (0.1, 0.1, 0.1), concentrating the belief towards the corners of the simplex and reducing entropy.
















### Entropy of Dirichlet Distribution

Let $\boldsymbol{\alpha} = (\alpha_1, \alpha_2, \dots, \alpha_K)$ be the parameters of a Dirichlet distribution. The entropy $H(\boldsymbol{\alpha})$ is given by:$

$$H(\boldsymbol{\alpha}) = \log B(\boldsymbol{\alpha}) + (\alpha_0 - K) \psi(\alpha_0) - \sum_{i=1}^{K} (\alpha_i - 1) \psi(\alpha_i)$$


where:

* $\alpha_0 = \sum_{i=1}^{K} \alpha_i$ is the total concentration
* $B(\boldsymbol{\alpha}) = \frac{\prod_{i=1}^{K} \Gamma(\alpha_i)}{\Gamma(\alpha_0)}$ is the multivariate Beta function

* $\psi(\cdot)$ is the digamma function: $\psi(x) = \frac{d}{dx} \log \Gamma(x)$
* $\Gamma(\cdot)$ is the Gamma function


Note that in the code below, we use the logarithm of the Beta function for numerical stability. $\text{term1} = \ln \Gamma(\alpha_0) - \sum_{i=1}^{K} \ln \Gamma(\alpha_i)$ is used to $\ln B(\boldsymbol{\alpha}) = \sum_{i=1}^{K} \ln \Gamma(\alpha_i) - \ln \Gamma(\alpha_0)$


```{r}
# Define alpha value sequences
alpha1_values <- seq(1, 0.1, by = -0.1)
alpha2_values <- seq(1, 0.1, by = -0.1)
alpha3_values <- seq(1, 0.1, by = -0.1)

# Entropy function for Dirichlet distribution
compute_entropy <- function(alpha) {
  alpha0 <- sum(alpha)
  K <- length(alpha)
  term1 <- lgamma(alpha0) - sum(lgamma(alpha))
  term2 <- (alpha0 - K) * digamma(alpha0)
  term3 <- -sum((alpha - 1) * digamma(alpha))
  return(term1 + term2 + term3)
}

# Compute entropy across combinations
entropy_values <- mapply(function(a1, a2, a3) {
  compute_entropy(c(a1, a2, a3))
}, alpha1_values, alpha2_values, alpha3_values)

# Construct data frame (corrected column names)
entropy_df <- data.frame(
  frame = seq_along(alpha1_values),
  alpha1 = alpha1_values,
  alpha2 = alpha2_values,
  alpha3 = alpha3_values,  # ✅ corrected from duplicate alpha2
  entropy = entropy_values
)

```



```{r}
# # Load required libraries

# Normalize entropy
entropy_df$normalized_entropy <- entropy_df$entropy - min(entropy_df$entropy)

# Prepare entropy line plot data (use base R subsetting)
entropy_line <- data.frame(
  step = seq_len(nrow(entropy_df)),
  normalized_entropy = entropy_df$normalized_entropy
)

# Extract start and end alpha vectors
alpha_start <- entropy_df[1, c("alpha1", "alpha2", "alpha3")]
alpha_end <- entropy_df[nrow(entropy_df), c("alpha1", "alpha2", "alpha3")]

# Create entropy trend line plot
entropy_plot <- ggplot(entropy_line, aes(x = step, y = normalized_entropy)) +
  geom_line(color = "red", size = 1.2) +
  labs(
    title = "Entropy Trend During Belief Shift",
    x = "Frame",
    y = "Normalized Entropy"
  )
# Combine plots side by side
entropy_plot 

```



```{r}
animate_dirichlet_evolution <- function(alpha1_values, alpha2_values, alpha3_values, n_samples = 2000) {
  library(ggplot2)
  library(gganimate)
  library(MCMCpack)
  library(grid)  # for arrow units
  
  # Triangle vertices
  v1 <- c(1, 0)
  v2 <- c(0, 1)
  v3 <- c(0, 0)
  
  # Label positions
  label_df <- data.frame(
    x = c(v1[1], v2[1], v3[1]),
    y = c(v1[2], v2[2], v3[2]),
    label = c("(1,0,0)", "(0,1,0)", "(0,0,1)"),
    nudge_x = c(-0.08, 0.1, 0),
    nudge_y = c(0, 0, 0.08)
  )
  
  # Triangle outline
  triangle_df <- data.frame(
    x = c(v1[1], v2[1], v3[1], v1[1]),
    y = c(v1[2], v2[2], v3[2], v1[2])
  )
  
  # Projection function
  project_to_triangle <- function(x1, x2, x3) {
    x <- x1 * v1[1] + x2 * v2[1] + x3 * v3[1]
    y <- x1 * v1[2] + x2 * v2[2] + x3 * v3[2]
    data.frame(x = x, y = y)
  }
  
  # Generate animation data
  animation_data <- do.call(rbind, lapply(seq_along(alpha1_values), function(i) {
    alpha <- c(alpha1_values[i], alpha2_values[i], alpha3_values[i])
    samples <- rdirichlet(n_samples, alpha)
    projected <- project_to_triangle(samples[,1], samples[,2], samples[,3])
    projected$alpha1 <- alpha[1]
    projected$alpha2 <- alpha[2]
    projected$alpha3 <- alpha[3]
    projected$frame <- i
    projected
  }))
  
  # Build plot
  p <- ggplot(animation_data, aes(x = x, y = y)) +
    geom_point(alpha = 0.3, size = 0.8, color = "steelblue") +
    geom_density_2d(color = "red", alpha = 0.7) +
    geom_path(data = triangle_df, aes(x = x, y = y), color = "black", size = 1) +
    annotate("segment", x = 1, y = 0, xend = 0, yend = 1,
             arrow = arrow(length = unit(0.2, "cm")),
             color = "darkgreen", size = 1.2) +
    xlim(0, 1) + ylim(0, 1) +
    geom_text(data = label_df,
              aes(x = x, y = y, label = label),
              nudge_x = label_df$nudge_x,
              nudge_y = label_df$nudge_y,
              size = 4, fontface = "bold", color = "black") +
    labs(
      title = "Dirichlet Prior Evolution",
      subtitle = "Shifting belief away from the uniform prior ",
      x = "Projected X",
      y = "Projected Y",
      caption = "Transitioning belief over simplex"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 14, hjust = 0.5),
      axis.title = element_text(size = 12),
      plot.caption = element_text(size = 10, hjust = 0.5)
    ) +
    transition_states(frame,
                      transition_length = 1,
                      state_length = 2) +
    ease_aes('sine-in-out')
  
  return(p)
}

```



```{r}
# Define alpha trajectories
alpha1 <- seq(1, 5, by = 0.1)
alpha2 <- seq(1, 5, by = 0.1)
alpha3 <- seq(1, 5, by = 0.1)

# Run animation
p <- animate_dirichlet_evolution(alpha1, alpha2, alpha3, n_samples = 2000)
animate(p, fps = 10, width = 600, height = 600)

```



### Mean and Variance

```{r}
# Define the alpha parameters
alpha <- c(.6, .6, .6)

# Calculate the sum of alpha
sum_alpha <- sum(alpha)

# Calculate the mean for each component
mean_dirichlet <- alpha / sum_alpha
print(mean_dirichlet)

# Calculate the variance for each component
variance_dirichlet <- (alpha * (sum_alpha - alpha)) / (sum_alpha^2 * (sum_alpha + 1))
print(variance_dirichlet)
```

```{r}
k <- seq(.1, 10, by = 0.1)

mean_dir <- numeric(length(k))
var_dir <- numeric(length(k))
for (i in seq_along(k)) {
  alpha <- k[i]
  sum_alpha <- alpha * 3
  mean_dir[i] <- alpha / sum_alpha
  var_dir[i] <- (alpha * (sum_alpha - alpha)) / (sum_alpha^2 * (sum_alpha + 1))
}
df <- data.frame(k = k, mean = mean_dir, variance = var_dir)


```


```{r}
plot(df$k,df$variance)
```


```{r}
# Define alpha trajectories
alpha1 <- seq(.1, 10, by = 0.1)
alpha2 <- seq(.1, 10, by = 0.1)
alpha3 <- seq(.1, 10, by = 0.1)

# Run animation
p <- animate_dirichlet_evolution(alpha1, alpha2, alpha3, n_samples = 2000)
animate(p, fps = 10, width = 600, height = 600)

```


```{r}
# Define alpha trajectories
alpha1 <- seq(.1, 10, by = 0.1)
alpha2 <- rep(5, length(alpha1))
alpha3 <- rep(5, length(alpha1))

# Run animation
p <- animate_dirichlet_evolution(alpha1, alpha2, alpha3, n_samples = 2000)
animate(p, fps = 10, width = 600, height = 600)

```


## New animation  functions
```{r}
generate_dirichlet_animation_data <- function(alpha1_values, alpha2_values, alpha3_values, n_samples = 2000) {
  library(MCMCpack)
  
  # Triangle vertices
  v1 <- c(1, 0)
  v2 <- c(0, 1)
  v3 <- c(0, 0)
  
  # Projection function
  project_to_triangle <- function(x1, x2, x3) {
    x <- x1 * v1[1] + x2 * v2[1] + x3 * v3[1]
    y <- x1 * v1[2] + x2 * v2[2] + x3 * v3[2]
    data.frame(x = x, y = y)
  }
  
  # Generate animation data
  animation_data <- do.call(rbind, lapply(seq_along(alpha1_values), function(i) {
    alpha <- c(alpha1_values[i], alpha2_values[i], alpha3_values[i])
    samples <- rdirichlet(n_samples, alpha)
    projected <- project_to_triangle(samples[,1], samples[,2], samples[,3])
    projected$alpha1 <- alpha[1]
    projected$alpha2 <- alpha[2]
    projected$alpha3 <- alpha[3]
    projected$frame <- i
    projected
  }))
  
  return(animation_data)
}

plot_dirichlet_evolution <- function(animation_data) {
  library(ggplot2)
  library(gganimate)
  library(grid)  # for arrow units
  
  # Triangle vertices
  v1 <- c(1, 0)
  v2 <- c(0, 1)
  v3 <- c(0, 0)
  
  # Label positions
  label_df <- data.frame(
    x = c(v1[1], v2[1], v3[1]),
    y = c(v1[2], v2[2], v3[2]),
    label = c("(1,0,0)", "(0,1,0)", "(0,0,1)"),
    nudge_x = c(-0.08, 0.1, 0),
    nudge_y = c(0, 0, 0.08)
  )
  
  # Triangle outline
  triangle_df <- data.frame(
    x = c(v1[1], v2[1], v3[1], v1[1]),
    y = c(v1[2], v2[2], v3[2], v1[2])
  )
  
  # Build plot
  p_animation <- ggplot(animation_data, aes(x = x, y = y)) +
    geom_point(alpha = 0.3, size = 0.8, color = "steelblue") +
    geom_density_2d(color = "red", alpha = 0.7) +
    geom_path(data = triangle_df, aes(x = x, y = y), color = "black", size = 1) +
    annotate("segment", x = 1, y = 0, xend = 0, yend = 1,
             arrow = arrow(length = unit(0.2, "cm")),
             color = "darkgreen", size = 1.2) +
    xlim(0, 1) + ylim(0, 1) +
    geom_text(data = label_df,
              aes(x = x, y = y, label = label),
              nudge_x = label_df$nudge_x,
              nudge_y = label_df$nudge_y,
              size = 4, fontface = "bold", color = "black") +
    labs(
      title = "Dirichlet Prior Evolution",
      subtitle = "",
      x = "Projected X",
      y = "Projected Y",
      caption = "Transitioning belief over simplex"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 14, hjust = 0.5),
      axis.title = element_text(size = 12),
      plot.caption = element_text(size = 10, hjust = 0.5)
    ) +
    transition_states(frame,
                      transition_length = 1,
                      state_length = 2) +
    ease_aes('sine-in-out')
  
  return(p_animation)
}

```

```{r}
#Define alpha trajectories
alpha1 <- seq(.1, 10, by = 0.1)
alpha2 <- seq(.1, 10, by = 0.1)
alpha3 <- seq(.1, 10, by = 0.1)

animation_data <- generate_dirichlet_animation_data(alpha1, alpha2, alpha3, n_samples = 2000)

plot_dirichlet_evolution(animation_data)

```



# Run animation
p <- animate_dirichlet_evolution(alpha1, alpha2, alpha3, n_samples = 2000)
animate(p_animation, fps = 10, width = 600, height = 600)

```


