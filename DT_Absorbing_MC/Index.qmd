---
title: "DT_A_MC"
author: "Joseph Rickert"
date: 2025-02-17
code-fold: true
code-summary: "Show the code"
description: ""
categories: ""
editor: source
---

## Required Packages and Helper Functions
```{r libraries}
#| message: FALSE
#| warning: FALSE
#| code-fold: true
#| code-summary: "R packages"
library('dplyr')
library('ggplot2')
library('stringr')
library('tidyverse')
library('matrixcalc')
library('LaplacesDemon') # for Dirichlet distribution
```


```{r}
#| code-fold: true
#| code-summary: "Helper Functions"
# names for transition probabilities
trans_names <- function(x) {
  transitions <- paste(x, "-", 1:5, sep = "")
  return(transitions)
  
}

# Bayesian simulation using Dirichlet conjugate prior
# matrix is the matrix of observed states
# from_state is the row index of the initial state
# n_sims is the number of simulations to run
sim_res <- function(matrix,from_state, n_sims = 20000) {
  priors <- matrix(rep(1, 20), nrow = 4) # Prior parameters for Dirichlet dist
  dist <- matrix[from_state, ] + priors[from_state, ]
  res <- rdirichlet(n_sims, dist)
  colnames(res) <- paste(from_state, "-", 1:5, sep = "")
  return(res)
}

smry <- function(res_matrix){
  apply(res_matrix, 2, function(x) {
  c(mean = mean(x), 
    lower = quantile(x, probs = 0.025), 
    upper = quantile(x, probs = 0.975))
})
}

# Function to compute the probability of being in each state at time t
prob_at_time <- function(matrix, time, i_state){
  u <- i_state
  index_eq_1 <- which(u == 1)
  m <- matrix.power(matrix, time)
  u_t <- u %*% m # Distribution at time t
 rownames(u_t) <- names(states)[index_eq_1]
 round(u_t,2)
}


#  Compute the expected time markov chain spends in state s, 
#  assuming it began in state si = c(1,0,0,0,0) (i.e. STW)
#   tpm - the transition probability matrix
#    n - the number of time periods
#    s -  the state of interest
time_in_state <- function(tpm, n, s){
  state_prob <- vector("numeric", length = n)
  index_eq_1 <- which(s == 1)
  si <- c(1,0,0,0,0)
  
  for (i in 1:n) {
    m <- si %*%  matrix.power(tpm, i)
    state_prob[i] <- m[index_eq_1]
}
Total_state_time <- sum(state_prob)
round(Total_state_time,2)
  
}
```

## The Data

The data used in this example originates from the randomized trial conducted by Kavuru et al. (2000) comparing the two treatments, Seretide and Fluticasone, for asthma management. The data is presented in the text and in the paper by Briggs et al. (2003) where state transitions were observed over a 12-week follow-up period. This data was also reported in the paper by Kavuru et al. (2000) and in Table 10.3 of the text.


```{r transition_data}
#| code-fold: true
#| code-summary: "Load the Data"
#| 
states <- c(
  'STW'='sucessfully treated week', 
  'UTW'='unsucessfully treated week', 
  'Hex'='hospital-managed exacerbation', 
  'Pex'='primary care-managed exacerbation', 
  'TF'='treatment failure'
)

treatments = c('Seretide', 'Fluticasone')

s_state <- matrix( c(
  210, 60, 0, 1, 1,
   88,641, 0, 4,13,
    0,   0, 0, 0, 0,
    1,   0, 0, 0, 1), 
   nrow=4, byrow=TRUE, 
   dimnames=list(names(states)[1:4], names(states)))

f_state <- matrix( c(
  66, 32, 0, 0, 2,
  42,752, 0, 5,20,
   0,  0, 0, 0, 0,
   0,  4, 0, 1, 0), 
  nrow=4, byrow=TRUE, 
  dimnames=list(names(states)[1:4], names(states)))


```


:::: {.columns}

::: {.column width="45%"}





```{r}
#| code-fold: true
#| code-summary: "Observed States for Seretide"
#| 
s_state
```
:::


::: {.column width="10%"}

:::

::: {.column width="45%"}





```{r}
#| code-fold: true
#| code-summary: "Obsereved States for Flucticasone"
#| 
f_state
```
:::

::::



## Conjugate Prior Results

In this section we compute the posterior distributions of the transition probabilities using the conjugate prior approach. The Dirichlet distribution is the conjugate prior for the multinomial distribution, so the posterior distribution is also a Dirichlet distribution. The parameters of the posterior distribution are the sum of the prior parameters and the observed counts.


### Seretide Simulations



```{r}
#| code-fold: true
#| code-summary: "Show the code"

s_STW_sim <- sim_res(matrix = s_state, from_state = 1)
s_STW_smry <- smry(s_STW_sim)

s_UTW_sim <- sim_res(matrix = s_state, from_state = 2)
s_UTW_smry <- smry(s_UTW_sim)

s_Hex_sim <- sim_res(matrix = s_state, from_state = 3)
s_Hex_smry <- smry(s_Hex_sim)

s_Pex_sim <- sim_res(matrix = s_state, from_state = 4)
s_Pex_smry <- smry(s_Pex_sim)

```


Plot the posterior distributions of the transition probabilities for Seretide starting in STW

```{r}
#| code-fold: true
#| code-summary: "Show the code"
# code for histogram of rd_df data frame
s_STW_sim_df <- s_STW_sim %>% 
  as.data.frame() %>%
  pivot_longer(cols=everything(), names_to="transitions", values_to="prob") 

ggplot(s_STW_sim_df, aes(x = prob)) +
  geom_histogram(aes(y = after_stat(density)),bins = 15, fill = "lightgrey", color = "black") + #histogram for each category
  geom_density(aes(y = after_stat(density)), color = "red", linewidth = 0.5) + # density line
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5)) +
  xlab("probability") +
  facet_wrap(~ transitions, scales = "free") +  # facetting for each category
  labs(
    title = "Seretide: Posterior State Transition Probabilities for states starting in STW",
    x = "Probability",
    y = " "
  ) 
```


### Flucticasone Simulations

```{r}
#| code-fold: true
#| code-summary: "Show the code"
f_STW_sim <- sim_res(matrix = f_state, from_state = 1)
f_STW_smry <- smry(f_STW_sim)

f_UTW_sim <- sim_res(matrix = f_state, from_state = 2)
f_UTW_smry <- smry(f_UTW_sim)

f_Hex_sim <- sim_res(matrix = s_state, from_state = 3)
f_Hex_smry <- smry(f_Hex_sim)

f_Pex_sim <- sim_res(matrix = s_state, from_state = 4)
f_Pex_smry <- smry(f_Pex_sim)
```


Plot the posterior distributions of the transition probabilities for Flucticasone starting in STW


```{r}
#| code-fold: true
#| code-summary: "Show the code"
# code for histogram of rd_df data frame
f_STW_sim_df <- f_STW_sim %>% 
  as.data.frame() %>%
  pivot_longer(cols=everything(), names_to="transitions", values_to="prob") 

ggplot(f_STW_sim_df, aes(x = prob)) +
  geom_histogram(aes(y = after_stat(density)),bins = 15, fill = "lightgrey", color = "black") + #histogram for each category
  geom_density(aes(y = after_stat(density)), color = "red", linewidth = 0.5) + # density line
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5)) +
  xlab("probability") +
  facet_wrap(~ transitions, scales = "free") +  # facetting for each category
  labs(
    title = "Flucticasone: Posterior State Transition Probabilities for states starting in STW",
    x = "Probability",
    y = " "
  ) 
```




## Theoretical Results

### Transition Probabilities

This constructs the transition probability matrices for both treatments using the means of the posterior distribution simulations.
```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Seretide transition Probabilities
s_TP <- rbind(
  s_STW_smry[1,],
  s_UTW_smry[1],
  s_Hex_smry[1,],
  s_Pex_smry[1,]
)

s_TP <- rbind(s_TP, c(0,0,0,0,1)) # Add the absorbing state TF
colnames(s_TP) <- c("STW", "UTW", "Hex", "Pex", "TF")
rownames(s_TP) <- c("STW", "UTW", "Hex", "Pex", "TF")
#s_TP

# Fluticasone transition Probabilities
f_TP <- rbind(
  f_STW_smry[1,],
  f_UTW_smry[1],
  f_Hex_smry[1,],
  f_Pex_smry[1,]
)
f_TP <- rbind(f_TP, c(0,0,0,0,1)) # Add the absorbing state TF
colnames(f_TP) <- c("STW", "UTW", "Hex", "Pex", "TF")
rownames(f_TP) <- c("STW", "UTW", "Hex", "Pex", "TF")

```

:::: {.columns}

::: {.column width="45%"}





```{r}
#| code-fold: true
#| code-summary: "Seretide Transition Probability Matrix"
round(s_TP,2)
```
:::


::: {.column width="10%"}

:::

::: {.column width="45%"}



```{r}
#| code-fold: true
#| code-summary: "Flucticasone Transition Probability Matrix"
round(f_TP,2)
```
:::

::::

### Fundamental Matrix

For an absorbing Markov Chain, the fundamental matrix, $N$, gives the expected number of times the process is in each transient state before absorption occurs. $N$ is calculated by the formula $N = (I - Q)^{-1}$, where $I$ is the identity matrix and $Q$ is the sub-matrix of transition probabilities for non-absorbing states.

The first step in computing $N$ is to partition the transition matrix into sub matrices of transient $Q_$, and absorbing $R$ transition probabilities.

![](N.png)


#### Extract the Q matrix


```{r}
#| code-fold: true
#| code-summary: "Show the code"
Q_s <- s_TP[1:4, 1:4] # Extract the sub-matrix of transition probabilities for non-absorbingstates

rownames(Q_s) <- names(states)[1:4]
colnames(Q_s) <- names(states)[1:4]# Set the row and column names to the state names
#round(Q_s,3)

Q_f <- f_TP[1:4, 1:4] # Extract the sub-matrix of transition probabilities for non-absorbing states

rownames(Q_f) <- names(states)[1:4]
colnames(Q_f) <- names(states)[1:4]# Set the row and column names to the state names
#round(Q_f,3)


```

:::: {.columns}

::: {.column width="45%"}


```{r}
#| code-fold: true
#| code-summary: "Seretide Q Matrix"
round(Q_s,2)
```

:::

::: {.column width="10%"}

:::

::: {.column width="45%"}


```{r}
#| code-fold: true
#| code-summary: "Flucticasone Q Matrix"
round(Q_f,2)
```


:::

::::

#### Extract the Fundamental Matrix, N. 

Each entry $n_ij$ of N gives the expected number of times that the process is in the transient state $s_j$ if it is started in the transient state $s_i$. For example, given that the process starts in state STW, the expected number of times the process is in each transient state before absorption occurs is given by the first row of $N$. 
.
```{r}
#| code-fold: true
#| code-summary: "Show the code"
I <- diag(4) # Identity matrix of size 4
N_s <- solve(I - Q_s) # Fundamental matrix for Seretide
#round(N_s,3)

N_f <- solve(I - Q_f) # Fundamental matrix for Flucticasone
#round(N_f,3)

```


:::: {.columns}

::: {.column width="45%"}


```{r}
#| code-fold: true
#| code-summary: "Seretide Fundamental Matrix"
round(N_s,2)
```

:::

::: {.column width="10%"}

:::

::: {.column width="45%"}


```{r}
#| code-fold: true
#| code-summary: "Flucticasone Fundamental Matrix"
round(N_f,2)
```

:::

::::


### Expected time to Absorption

The expected time to absorption from each transient state is given by the formula $t = Nc$, where $c$ is a vector of ones. This means that the expected time to absorption from each transient state is the sum of the expected number of times the process is in each transient state before absorption occurs.



```{r}
#| code-fold: true
#| code-summary: "Show the code"
# Calculation for Seretide
c <- c(1,1,1,1)
E_s <- N_s %*% c # Expected time to absorption for Seretide
colnames(E_s) <- "Seretide"
#round(E_s,2)

#| code-fold: true
#| code-summary: "Show the code"
#Calculation for Fluticasone
E_f <- N_f %*% c # Expected time to absorption for Flucticasone
colnames(E_f) <- "Flucticasone"
#round(E_f,2)

# Combine the expected times to absorption for both treatments
E <- cbind(E_s, E_f) %>% data.frame()
round(E,2)
```

### Distribution at time t

Probability of being in each state at time t starting from state STW as given by $P(s = i | time = t) = uP^t$ where $u$ is the initial state vector, and $P$ is the transition probability matrix. Following the text, we set t = 12 weeks..


```{r}
#| code-fold: true
#| code-summary: "Show the code"
# Seretide
t <- 12
u <- c(1,0,0,0,0) # Initial state vector, starting in STW
spt <- prob_at_time(s_TP, t, u)

#Flucticasone
t <- 12
u <- c(1,0,0,0,0) # Initial state vector, starting in STW
fpt <- prob_at_time(f_TP, t, u)


p_in_state <- rbind(spt,fpt)
rownames(p_in_state) <- c("Seretide start STW", "Fluticasone start STW")
p_in_state

``` 

### Expected time spent in selected state

This section computes the expected time the markov chain will spend in state s, assuming that it begins in STW.


```{r}
#| code-fold: true
#| code-summary: "Show the code"
# Seretide
t <- 12
u <- c(1,0,0,0,0) # Initial state vector, starting in STW
s_time <- time_in_state(tpm = s_TP, n = t, s = u)

# Flucticasone
t <- 12
u <- c(1,0,0,0,0) # Initial state vector, starting in STW
f_time <- time_in_state(tpm = f_TP, n = t, s = u)

rbind(s_time, f_time) %>% 
  data.frame(row.names=c("Seretide", "Fluticasone")) %>% 
  setNames("STW") %>% 
  round(2)
```


